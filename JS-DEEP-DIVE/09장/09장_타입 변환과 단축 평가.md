### **9장 타입 변환과 단축 평가**

자바스크립트에서는 **명시적 타입 변환**과 **암묵적 타입 변환**이 빈번하게 발생하며, 논리 연산자를 통해 간단히 조건 처리를 수행할 수 있다.

---

### **타입 변환 (Type Conversion)**

자바스크립트에서는 **명시적 타입 변환**과 **암묵적 타입 변환**이 자주 발생한다. 이 과정은 값의 타입이 다를 때, 이를 적절하게 변환하여 연산할 수 있도록 도와준다.

### 🔄 **명시적 타입 변환 (Explicit Type Conversion)**

명시적 타입 변환은 개발자가 의도적으로 값을 다른 타입으로 변환하는 것이다. 자바스크립트에서 **`String()`**, **`Number()`**, **`Boolean()`** 등의 내장 함수를 사용하여 타입을 변환한다.

- **`String()`**: 값이 어떤 타입이든지 문자열로 변환한다.
- **`Number()`**: 값을 숫자로 변환한다. 변환할 수 없는 경우 `NaN`이 반환된다.
- **`Boolean()`**: 값이 `falsy`이면 `false`, 그 외에는 `true`로 변환된다.

**예제:**

```jsx
String(123); // "123"
Number("456"); // 456
Boolean(0); // false
```

### 🎭 **암묵적 타입 변환 (Implicit Type Conversion)**

암묵적 타입 변환은 자바스크립트 엔진이 자동으로 변환하는 것이다. 예를 들어, 숫자와 문자열을 더할 때 자바스크립트는 숫자를 문자열로 자동으로 변환하여 처리한다.

- 자바스크립트에서 `+` 연산자는 숫자와 문자열을 더할 때, 숫자를 문자열로 변환하여 연산한다.
- `==` 연산자도 타입을 강제로 변환하여 비교를 수행한다.

**예제:**

```jsx
1 + "1"; // '11' (숫자 1이 문자열 '1'로 변환되어 문자열 결합)
"5" - 2; // 3   (문자열 '5'가 숫자 5로 변환되어 계산)
true + 1; // 2   (불린 값 `true`가 1로 변환되어 계산)
```

---

### **단축 평가 (Short-circuit Evaluation)**

단축 평가는 논리 연산자에서 조건이 이미 확정된 경우, 나머지 연산을 건너뛰는 방법이다. 자바스크립트에서는 **`&&`**, **`||`**, **`??`** 연산자가 이를 사용한다.

### `&&` (AND)

`&&` 연산자는 좌측 값이 `falsy`일 경우 우측 값을 평가하지 않는다. 이를 통해 불필요한 연산을 피할 수 있다.

**예제:**

```jsx
"A" && "B"; // 'B' (좌측 값 'A'가 truthy이므로, 우측 값을 반환)
false && "B"; // false (좌측 값이 falsy이므로 우측 값을 평가하지 않음)
```

### `||` (OR)

`||` 연산자는 좌측 값이 `truthy`일 경우 우측 값을 평가하지 않는다. 이때 좌측 값이 바로 반환된다.

**예제:**

```jsx
"A" || "B"; // 'A' (좌측 값이 truthy이므로 우측 값을 평가하지 않음)
false || "B"; // 'B' (좌측 값이 falsy이므로 우측 값을 반환)
```

### `??` (Nullish Coalescing)

`??` 연산자는 좌측 값이 `null` 또는 `undefined`일 경우에만 우측 값을 반환한다. 다른 `falsy` 값 (예: `0`, `false`, `NaN`)은 무시하고 좌측 값을 그대로 반환한다.

**예제:**

```jsx
null ?? "default"; // 'default'
undefined ?? "default"; // 'default'
false ?? "default"; // false
0 ?? "default"; // 0
```

---

### **옵셔널 체이닝 (Optional Chaining)**

옵셔널 체이닝은 객체의 속성에 접근할 때 해당 속성이 존재하지 않는 경우 오류를 방지하고 `undefined`를 반환하는 방법이다. 이를 통해 깊은 중첩 객체의 속성에 안전하게 접근할 수 있다.

**예제:**

```jsx
const obj = { a: { b: { c: 5 } } };
obj?.a?.b?.c; // 5
obj?.x?.y?.z; // undefined
```

이렇게 옵셔널 체이닝을 사용하면, 속성이 없거나 `null`인 경우에도 오류 없이 안전하게 접근할 수 있다.

---

### 🎯 요약

**타입 변환**

| 🏷️ **구분**             | 📜 **설명**                                                        | 🛠️ **예제**            |
| ----------------------- | ------------------------------------------------------------------ | ---------------------- |
| 🔄 **명시적 타입 변환** | - 명시적으로 타입을 변환.<br>- 예: `String(123)`, `Number('456')`. | `Number('123') // 123` |
| 🎭 **암묵적 타입 변환** | - 자바스크립트 엔진이 자동으로 변환.<br>- 예: `1 + '1' → '11'`.    | `1 + '1' // '11'`      |

---

### **단축 평가**

| 🏷️ **연산자** | 📜 **설명**                               | 🛠️ **예제**                      |
| ------------- | ----------------------------------------- | -------------------------------- |
| `&&`          | - 첫 번째 falsy 값을 반환.                | `'A' && 'B' // 'B'`              |
| `??`          | - null 또는 undefined일 때만 대체값 반환. | `null ?? 'default' // 'default'` |

---

### **옵셔널 체이닝**

| 🏷️ **연산자** | 📜 **설명**                                                      | 🛠️ **예제**                  |
| ------------- | ---------------------------------------------------------------- | ---------------------------- |
| `?.`          | - 존재하지 않는 속성 접근 시 오류를 방지하고 `undefined`를 반환. | `obj?.property // undefined` |
|               |                                                                  |                              |

### 💡핵심

- 명시적 타입 변환을 통해 안전한 코드 작성
- 단축 평가(`&&`, `||`, `??`)로 조건을 간결하게 처리
- 옵셔널 체이닝(`?.`)으로 안전한 속성 접근
