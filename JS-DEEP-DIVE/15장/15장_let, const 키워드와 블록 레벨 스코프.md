### **15장: let, const 키워드와 블록 레벨 스코프** 🐾

---

### 1. **var의 문제점** 😟

- **함수 레벨 스코프**만 지원하므로 블록 스코프가 적용되지 않는다.
    
    ```jsx
    if (true) {
        var x = 10;
    }
    console.log(x); // 10 (블록 밖에서도 접근 가능)
    ```
    
- **변수 호이스팅**으로 인해 선언 전에 변수에 접근할 수 있다.
    
    ```jsx
    console.log(x); // undefined
    var x = 10;
    ```
    
- **중복 선언 허용**으로 예기치 않은 변수 덮어쓰기가 발생할 수 있다.
    
    ```jsx
    var x = 10;
    var x = 20; // 오류 없이 실행됨
    ```
    

---

### 2. **let 키워드** ✨

- **블록 레벨 스코프**를 지원한다. 블록 내부에서만 변수를 참조할 수 있다.
    
    ```jsx
    if (true) {
        let x = 10;
        console.log(x); // 10
    }
    console.log(x); // ReferenceError
    ```
    
- **변수 호이스팅**은 발생하지만, 선언 전에 변수를 사용할 수 없다.
    
    ```jsx
    console.log(x); // ReferenceError
    let x = 10;
    ```
    
- **중복 선언 금지**로 변수 덮어쓰기를 방지한다.
    
    ```jsx
    let x = 10;
    let x = 20; // SyntaxError
    ```
    

---

### 3. **const 키워드** 🔒

- **값을 재할당할 수 없는 상수**를 선언할 때 사용한다.
    
    ```jsx
    const x = 10;
    x = 20; // TypeError
    ```
    
- **블록 레벨 스코프**를 지원하며, 선언과 초기화를 동시에 해야 한다.
    
    ```jsx
    const x; // SyntaxError
    x = 10;
    ```
    
- **객체나 배열은 변경 가능**하지만, 참조 자체를 변경할 수 없다.
    
    ```jsx
    const obj = { key: 'value' };
    obj.key = 'newValue'; // 가능
    obj = {}; // TypeError
    ```
    

---

### 4. **블록 레벨 스코프** 🧱

- 블록 `{}` 내부에서 선언된 변수는 블록 외부에서 접근할 수 없다.
- `let`과 `const`는 블록 레벨 스코프를 지원하여 변수가 필요한 범위에서만 유효하도록 만든다.
    
    ```jsx
    {
        let x = 10;
        const y = 20;
        console.log(x, y); // 10, 20
    }
    console.log(x, y); // ReferenceError
    
    ```
    
- 블록 레벨 스코프는 전역 오염을 방지하고, 코드의 가독성과 유지보수성을 높인다.

---

### 5. **let과 const의 선택 기준** 🌟

- **재할당이 필요한 경우**: `let`을 사용한다.
- **재할당이 필요 없는 경우**: `const`를 사용한다.
- 기본적으로 `const`를 사용하고, 꼭 필요한 경우에만 `let`을 사용하는 것이 권장된다.

---

### 💡핵심

- `let`: 상황에 따라 변할 수 있음.
- `const`: 절대 변하지 않음.

이 둘은 블록 레벨 스코프를 지원한다.
